- 프로그램 : 코드(명령어)의 집합
- 프로세스 : 현재 실행 중인 프로그램
- 멀티 테스킹 : *하나의 프로그램*에서 두가지 이상의 작업을 동시에 처리하는 것
- 멀티 프로세스 : 운영체제가 동시에 *여러개의 프로세스*를 생성하여 처리하는 것
-> 멀티 프로세스 : 프로그램 단위의 멀티 테스킹
-> 멀티 스레드 :  프로그램 내부에서 멀티 테스킹


[스레드]
- 정의 : 프로세스 내에서 실행되는 작업 단위
    -> 각 프로세스는 최소 한 개의 스레드를 포함함 *!!!무조건!!!*
    -> 자바는 main 함수가 main 스레드를 포함하므로써 하나의 프로세스(프로그램)을 만들 수 있음
    ※ JS 는 스레드(main) 함수가 존재하지 않는 이유 : 브라우저(프로그램)가 JS 를 읽어들이기 때문에 브라우저 스레드를 사용 ※
- 목적 : 코드(명령어)를 읽어들이고 CPU 가 처리하기 위함
- 자바에서의 스레드
    -> main 함수 : public static void main(String[] args) 에는 main 스레드가 내장됨

[멀티 스레드]
- 정의 : main 함수 외 새로운 작업 스레드를 생성하는 경우
- 목적 : 병렬처리
- 사용처
    1) 동기화 / 비동기화 처리 시
    2) 소켓
    3) 파일처리
    4) REST API
    5) JDBC
    등등~~~

[멀티스레드 사용]
- Thread 클래스 : 새로운 스레드를 생성할 때 사용되는 클래스
    => 다른 클래스를 상속받을 수 없음
    <주요 메소드>
    1) run() : 새로운 스레드가 처리(실행)할 코드를 정의
    2) start() : 새로운 스레드 실행

- Runnable 인터페이스 : 새로운 스레드를 생성할 때 사용되는 인터페이스
    => 다른 클래스를 상속할 수 있음
    <주요 추상 메소드>
    1) run() : 새로운 스레드가 처리(실행)할 코드를 정의
- 멀티스레드 사용법
    1) 익명객체 사용 : implement 없이 즉석에서 추상메소드를 구현하여 사용
        예] Thread 스레드명 = new Thread( new Runnable (){ @Override run(){} })
    2) 구현객체 사용 : implement 를 통해 인터페이스의 추상메소드를 구현하여 사용
        예] class 클래스명 implements Runnable{ @Override run(){} }
    3) 상속객체 사용 : extends 를 통해 상속받은 메소드를 오버라이딩하여 사용
        예] class 클래스명 extends Thread{ @Override run(){} }

    => 여러번 사용하기 위해 주로 구현객체를 사용
    => Runnable 은 인터페이스로 new Runnable 을 통한 인스턴스 생성 불가능 (익명객체를 사용하면 가능)

[스레드 풀]
- 정의 : 미리 일정 개수의 스레드를 생성하고 필용에 따라 재사용하는 방식
- 목적
    1) 작업이 들어올 때마다 새로운 스레드가 아닌 기존 스레드를 재사용하기 위함
    2) 불필요한 스레드를 제거하여 자원을 효율적으로 사용
    3) 과부화 방지
    4) 비용절감
- 구조 : 작업의 요청을 '큐'라는 자료구조로 배치하여 순서대로 스레드풀에서 대기중인 스레드에게 작업배정
    ★ 큐 : 작업의 순서를 요청순서대로 처리하는 자료구조 ★

           --------------------------------
    -입구-> [요청4]  [요청3]  [요청2]  [요청1] -출구->
           --------------------------------
                   <스레드풀>
              :---> [스레드1]
    [큐] -배정-:---> [스레드2]
              :---> [스레드3]

- 사용처
    1) Tomcat(Servlet)
    2) JDBC
    3) 파일처리(파일 업로드 등)
- 사용방법
    1) 스레드풀 생성
        ExecutorService 스레드풀변수명 = Executors.newFixedThreadPool(스레드개수);
    2) 스레드풀에 스레드 등록
        스레드풀변수명.submit(new 인터페이스명(){ 추상메소드구현코드 });
    3) 스레드풀 종료
        스레드풀변수명.shutdown();


[스프링에서의 멀티스레드 사용]
1. AppStart 클래스에 @EnableAsync 어노테이션 주입
2. 멀티스레드 적용
    -> 비동기화
        1) 멀티스레드를 적용할 메소드 위에 @Async 어노테이션 주입
    -> 동기화
        1) 멀티스레드를 적용할 메소드 위에 @Async 어노테이션 주입
        2) synchronized 키워드를 통해 동기화 처리
           방법1_ 접근제한자 synchronized 리턴타입 메소드명 () {}
           방법2_ synchronized { } 블록 사용

[스프링에서의 스레드풀]
- 스프링은 기본적으로 스레드풀을 사용 (최소 8개의 스레드 사용)
- 스프링의 기본적인 스레드풀을 커스텀하여 정의 가능
- 사용법
    1) 스프링에 내장된 스레드풀을 커스텀하는 클래스 생성
        @Configuration // 설정 클래스 빈을 컨테이너에 등록하는 어노테이션
        public class 클래스명 { }
    2) 스레드풀을 커스텀할 메소드를 @Bean 어노테이션을 통해 컨테이너에 bean 등록
    3) 스레드풀 객체 선언
       ThreadPoolTaskExecutor 스레드풀변수명 = new ThreadPoolTaskExecutor();
    4) 스프레드풀 커스텀
        - 최소 실행 스레드 개수 설정 : 스프레드풀변수명.setCorePoolSize(개수);
        - 최대 실행 스레드 개수 설정 : 스프레드풀변수명.setMaxPoolSize(개수);
        - 대기 큐 개수 설정 : 스프레드풀변수명.setQueueCapacity(개수);
        - 스레드 이름 설정 : 스프레드풀변수명.setThreadNamePrefix("이름");
        - 스레드풀 초기화 : 스프레드풀변수명.initialize();
    5) 커스텀한 스레드풀 객체 return


[용어정리]
1. @EnableAsync : 멀티스레드 기능을 활성화 시키는 어노테이션
2. @Async : 메소드에 멀티스레드를 적용시키는 어노테이션
3. synchronized 키워드 : 동기화 처리



----------------------------------------------------------------------------

★ 클래스와 인터페이스의 차이점 ★
-> 클래스
    1) 함수의 구현
    2) 멤버변수 존재 가능
    3) 단일 상속
    4) 인스턴스 생성 가능
-> 인터페이스
    1) 함수의 선언
    2) 상수변수만 존재 가능
    3) 다중 상속
    4) 인스턴스 생성 불가능 => 익명객체 구현 시 가능

★ extends(상속) 와 implement(구현) 의 차이 ★
-> extends : 한번만 상속가능
-> implement : 여러번 구현가능

★ 구현객체와 익명객체★
-> 구현(객)체 : implement 를 통해 추상메소드를 갖는 인터페이스를 구현한 클래스의 객체
-> 익명(객)체 : implement 없이 추상메소드를 즉석에서 구현한 객체

★ 동기화 ★
-> 동기화 키워드(synchronized)
-> 동기화 사용법
    1) 메소드 선언부의 반환타입 앞에 synchronized 키워드 사용
    2) synchronized (this) { }  블럭 사용
-> 사용목적 : 멀티스레드에서 하나의 자원에 동시에 접근 시 충돌 방지
-> 동기화 와 비동기화의 차이
    1) 동기화
        - 한번에 하나의 스레드를 처리 (순서 보장)
        - 하나씩 처리하므로 상대적으로 속도 ↓
    2) 비동기화
        - 여러개의 스레드를 동시에 처리 (순서 보장 X)
        - 병렬처리를 하므로 상대적으로 속도 ↑






