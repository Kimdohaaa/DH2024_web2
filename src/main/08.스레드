- 프로그램 : 코드(명령어)의 집합
- 프로세스 : 현재 실행 중인 프로그램
- 멀티 테스킹 : *하나의 프로그램*에서 두가지 이상의 작업을 동시에 처리하는 것
- 멀티 프로세스 : 운영체제가 동시에 *여러개의 프로세스*를 생성하여 처리하는 것
-> 멀티 프로세스 : 프로그램 단위의 멀티 테스킹
-> 멀티 스레드 :  프로그램 내부에서 멀티 테스킹


[스레드]
- 정의 : 프로세스 내에서 실행되는 작업 단위
    -> 각 프로세스는 최소 한 개의 스레드를 포함함 *!!!무조건!!!*
    -> 자바는 main 함수가 main 스레드를 포함하므로써 하나의 프로세스(프로그램)을 만들 수 있음
    ※ JS 는 스레드(main) 함수가 존재하지 않는 이유 : 브라우저(프로그램)가 JS 를 읽어들이기 때문에 브라우저 스레드를 사용 ※
- 목적 : 코드(명령어)를 읽어들이고 CPU 가 처리하기 위함
- 자바에서의 스레드
    -> main 함수 : public static void main(String[] args) 에는 main 스레드가 내장됨

[멀티 스레드]
- 정의 : main 함수 외 새로운 작업 스레드를 생성하는 경우
- 목적 : 병렬처리
- 사용처
    1) 동기화 / 비동기화 처리 시
    2) 소켓
    3) 파일처리
    4) REST API
    5) JDBC
    등등~~~

[멀티스레드 사용]
- Thread 클래스 : 새로운 스레드를 생성할 때 사용되는 클래스
    => 다른 클래스를 상속받을 수 없음
    <주요 메소드>
    1) run() : 새로운 스레드가 처리(실행)할 코드를 정의
    2) start() : 새로운 스레드 실행

- Runnable 인터페이스 : 새로운 스레드를 생성할 때 사용되는 인터페이스
    => 다른 클래스를 상속할 수 있음
    <주요 추상 메소드>
    1) run() : 새로운 스레드가 처리(실행)할 코드를 정의
- 멀티스레드 사용법
    1) 익명객체 사용 : implement 없이 즉석에서 추상메소드를 구현하여 사용
        예] Thread 스레드명 = new Thread( new Runnable (){ @Override run(){} })
    2) 구현객체 사용 : implement 를 통해 인터페이스의 추상메소드를 구현하여 사용
        예] class 클래스명 implements Runnable{ @Override run(){} }
    3) 상속객체 사용 : extends 를 통해 상속받은 메소드를 오버라이딩하여 사용
        예] class 클래스명 extends Thread{ @Override run(){} }

    => 여러번 사용하기 위해 주로 구현객체를 사용
    => Runnable 은 인터페이스로 new Runnable 을 통한 인스턴스 생성 불가능 (익명객체를 사용하면 가능)

★ 클래스와 인터페이스의 차이점 ★
-> 클래스
    1) 함수의 구현
    2) 멤버변수 존재 가능
    3) 단일 상속
    4) 인스턴스 생성 가능
-> 인터페이스
    1) 함수의 선언
    2) 상수변수만 존재 가능
    3) 다중 상속
    4) 인스턴스 생성 불가능 => 익명객체 구현 시 가능

★ extends(상속) 와 implement(구현) 의 차이 ★
-> extends : 한번만 상속가능
-> implement : 여러번 구현가능

★ 구현객체와 익명객체★
-> 구현(객)체 : implement 를 통해 추상메소드를 갖는 인터페이스를 구현한 클래스의 객체
-> 익명(객)체 : implement 없이 추상메소드를 즉석에서 구현한 객체










